# 1、继承概述

## 1.1继承

- 继承是类与类之间的一种关系
- 多个类继承单独的某个类，多个类就可以使用单独的这个类的属性和行为了。

- Student（多个类）称为子类（派生类），People（单类）称为父类(基类 或超类)

![](笔记图片资源包\snipaste20220122_093626.jpg)

### 继承的好处

- 当子类继承父类后，就可以直接使用父类公共的属性和方法了。这样减少了代码冗余，因此，用好这个技术可以很好的我们提高代码的复用性，增强类的功能扩展性。

### 继承的格式

- Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。

![](笔记图片资源包\snipaste20220122_093223.jpg)

- 其中Student为子类名，People为父类名

#### 思考

##### 继承后子类的特点？

- 子类 继承父类，子类可以得到父类的属性和行为，子类可以使用。
- Java中子类更强大

##### 继承有好处，坏处是什么呢？

- 有些不相干的类并不需要使用继承。
- 耦合性太大
- 破坏了类的封装性，且继承多用于抽象方法的继承和接口的实现

### 继承设计规范

- 子类们相同特征（共性属性，共性方法）放在父类中定义，子类独有的的属性和行为应该定义在子类自己里面。

#### 思考

##### 为什么要这样做？

- 如果子类的独有属性、行为定义在父类中，会导致其它子类也会得到这些属性和行为，这不符合面向对象逻辑。

##### 继承需要满足什么样的设计规范？

- 子类们相同特征（共性属性，共性方法）放在父类中定义。
- 子类独有的的属性和行为应该定义在子类自己里面。

# 2、继承的特点与思考

## 2.1、继承的特点

- 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。
- Java是单继承模式：一个类只能继承一个直接父类。
- Java不支持多继承、但是支持多层继承。
- Java中所有的类都是Object类的子类。

## 2.2、关于继承的思考

### 子类是否可以继承父类的构造器？

- 不可以的，子类有自己的构造器，父类构造器用于初始化父类对象

### 子类是否可以继承父类的私有成员？

- 可以的，只是不能直接访问。可以访问私有对象，方法不能调用

![](笔记图片资源包\snipaste20220122_123531.jpg)

### 子类是否可以继承父类的静态成员？

- 有争议的知识点。
- 子类可以直接使用父类的静态成员（共享）
- 但个人认为：子类不能继承父类的静态成员。（共享并非继承）

## 2.3、单继承与多继承

- java只支持单继承，而不支持多继承
- 单继承:子类只能继承一个直接父类
- 不支持多继承：子类不能同时继承多个父类

- 虽然java不支持多继承，但支持多层继承

### 多层继承

- 子类A继承父类B，父类B可以继承父类C

### Object特点

- java所有的类，要么直接继承Object，要么默认继承Object，要么间接继承Object，因此Object是祖宗类。

# 3、继承后：成员变量、成员方法的访问特点

## 访问概述

- 在子类方法中访问成员（成员变量、成员方法）满足：就近原则

### 就近原则

- 先在子类局部范围找
- 然后在子类成员范围找
- 最后在父类成员范围找，如果父类范围还没有找到则报错。

## 特殊情况

### 重名情况

- 如果子父类中，出现了重名的成员，会优先使用子类。

#### 思考

##### 此时如果一定要在子类中使用父类的怎么办？

- 可以通过super关键字，指定访问父类的成员。

![](笔记图片资源包\snipaste20220122_172408.jpg)

##### 如果要访问子类又该如何？

```JAVA
格式：this.子类成员变量/子类成员方法
```

###### 示例

```java
package com.gewuyou.d10_extends_field_method;

public class ExtendsDemo {
    public static void main(String[] args) {
        Wolf wolf=new Wolf();
        System.out.println(wolf.name);
        wolf.showName();

    }


}
class Animal{
    public  String name="父类动物";

}
class Wolf extends Animal{
    public String name="子类动物";
    public void showName(){
        String name="局部名称";
        System.out.println(name);//访问的是局部子类
        //如果要访问子类的name应该如何操作
        System.out.println(this.name);//访问当前子类的name
        //如果要访问父类name该如何操作
        System.out.println(super.name);
    }
}
-----------------------输出结果-----------------------
子类动物
局部名称
子类动物
父类动物
-----------------------方法使用-----------------------    
package com.gewuyou.d10_extends_field_method;

public class ExtendsDemo2 {
    public static void main(String[] args) {
        Student student=new Student();
        student.run();
        student.go();
        
    }


}

class People{
    public  String name="人类";
    public void run(){
        System.out.println("你还不是不够努力！！！！");
    }

}
//要使用父类方法而不使用子类方法必须建一个新方法中转，通过super指向父类
class Student extends People{
    public String name="学生";
    public void run(){
        System.out.println("我直接躺平！！！！");
    }
    public void go(){
        super.run();
    }

}
-----------------------输出结果-----------------------
我直接躺平！！！！
你还不是不够努力！！！！    
```

# 4、继承后：方法重写

## 4.1、方法重写的概念

- 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。

## 4.2、方法重写的应用场景

- 当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。
- 子类可以重写父类中的方法。

### 案例演示

- 旧手机的功能只能是基本的打电话，发信息
- 新手机的功能需要能够：基本的打电话下支持视频通话。基本的发信息下支持发送语音和图片。

### @Override重写注解

- @Override是放在重写后的方法上，作为重写是否正确的校验注解。
- 加上该注解后如果重写错误，编译阶段会出现错误提示。
- 建议重写方法都加@Override注解，代码安全，优雅！

#### 示例

```java
@Override
    public void sendMessage(){
        super.sendMessage();
        System.out.println("支持发送图片和视频~~");
    }
```

## 4.3、方法重写注意事项和要求

- 重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。
- 私有方法不能被重写。
- 子类重写父类方法时，访问权限必须大于或者等于父类 （暂时了解 ：缺省 < protected < public）
- 子类不能重写父类的静态方法，如果重写会报错的。

# 5、继承后：子类构造器的特点

## 子类继承父类后构造器的特点：

- 子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。

## 思考

#### 为什么会有这样的特点？

- 子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。
- 子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。

#### 怎么调用父类构造器的？

- 子类构造器的第一行语句默认都是：super()；，不写也存在。

# 6、继承后：子类构造器访问父类有参构造器

## super调用父类有参数构造器的作用

-  初始化继承自父类的数据。

## 思考

#### 如果父类中没有无参数构造器，只有有参构造器，会出现什么现象呢？

- 会报错。因为子类默认是调用父类无参构造器的。

#### 如何解决？

- 子类构造器中可以通过书写 super(…)，手动调用父类的有参数构造器

#### super调用父类构造器的作用是什么？

- 通过调用父类有参数构造器来初始化继承自父类的数据

# 7、this、super使用总结

## 7.1、this和super详情

- this：代表本类对象的引用。
- super：代表父类存储空间的标识。

![](笔记图片资源包\snipaste20220122_201350.jpg)

- 实际上，在以上的总结中，唯独只有this调用本类其他构造器我们是没有接触过的。

## 7.2、this(...)和super(…)使用注意点

- 子类通过 this (...）去调用本类的其他构造器，本类其他构造器会通过 super 去手动调用父类的构造器，最终还是会调用父类构造器的。
- 注意：this(…) super(…) 都只能放在构造器的第一行，所以二者不能共存在同一个构造器中。