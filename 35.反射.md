# 反射

## 反射概述

### 概述

- 反射是指对于任何一个Class类，在"运行的时候"都可以直接得到这个类全部成分。
- 在运行时,可以直接得到这个类的构造器对象：Constructor
- 在运行时,可以直接得到这个类的成员变量对象：Field
- 在运行时,可以直接得到这个类的成员方法对象：Method
- 这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。

### 反射的关键

- 反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。

```java
HelloWorld.java -> javac -> HelloWorld.class
Class c = HelloWorld.class;
```

### 小节

#### 反射的基本作用、关键？

- 反射是在运行时获取类的字节码文件对象：然后可以解析类中的全部成分。
- 反射的核心思想和关键就是:得到编译以后的class文件对象。

## 反射获取类对象

### 小节

#### 反射的第一步是什么？

- 获取Class类对象，如此才可以解析类的全部成分

#### 获取Class类的对象的三种方式

- 方式一：Class c1 = Class.forName(“全类名”);
- 方式二：Class c2 = 类名.class
- 方式三：Class c3 = 对象.getClass();

```java
public static void main(String[] args) throws Exception {
    // 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)
    Class c = Class.forName("com.itheima.d2_reflect_class.Student");
    System.out.println(c); // Student.class

    // 2、类名.class
    Class c1 = Student.class;
    System.out.println(c1);

    // 3、对象.getClass() 获取对象对应类的Class对象。
    Student s = new Student();
    Class c2 = s.getClass();
    System.out.println(c2);
}
```

## 反射获取构造器对象

### 使用反射技术获取构造器对象并使用

![](笔记图片资源包\snipaste20220224_140712.jpg)

- 反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。
- Class类中用于获取构造器的方法

| 方法                                                         | 说明                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| Constructor<?>[]  getConstructors()                          | 返回所有构造器对象的数组（只能拿public的） |
| Constructor<?>[]  getDeclaredConstructors()                  | 返回所有构造器对象的数组，存在就能拿到     |
| Constructor<T>  getConstructor(Class<?>...  parameterTypes)  | 返回单个构造器对象（只能拿public的）       |
| Constructor<T>  getDeclaredConstructor(Class<?>...  parameterTypes) | 返回单个构造器对象，存在就能拿到           |

- 获取构造器的作用依然是初始化一个对象返回。

```java
/**
    目标：反射_获取Constructor构造器对象.

    反射的第一步是先得到Class类对象。（Class文件）

    反射中Class类型获取构造器提供了很多的API:
         1. Constructor getConstructor(Class... parameterTypes)
            根据参数匹配获取某个构造器，只能拿public修饰的构造器，几乎不用！
         2. Constructor getDeclaredConstructor(Class... parameterTypes)
            根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！
         3. Constructor[] getConstructors()
            获取所有的构造器，只能拿public修饰的构造器。几乎不用！！太弱了！
         4. Constructor[] getDeclaredConstructors()
            获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！
    小结：
        获取类的全部构造器对象： Constructor[] getDeclaredConstructors()
            -- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！
        获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)
            -- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！

 */
public class TestStudent01 {
    // 1. getConstructors:
    // 获取全部的构造器：只能获取public修饰的构造器。
    // Constructor[] getConstructors()
    @Test
    public void getConstructors(){
        // a.第一步：获取类对象
        Class c = Student.class;
        // b.提取类中的全部的构造器对象(这里只能拿public修饰)
        Constructor[] constructors = c.getConstructors();
        // c.遍历构造器
        for (Constructor constructor : constructors) {
            System.out.println(constructor.getName() + "===>" + constructor.getParameterCount());
        }
    }


    // 2.getDeclaredConstructors():
    // 获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。
    @Test
    public void getDeclaredConstructors(){
        // a.第一步：获取类对象
        Class c = Student.class;
        // b.提取类中的全部的构造器对象
        Constructor[] constructors = c.getDeclaredConstructors();
        // c.遍历构造器
        for (Constructor constructor : constructors) {
            System.out.println(constructor.getName() + "===>" + constructor.getParameterCount());
        }
    }

    // 3.getConstructor(Class... parameterTypes)
    // 获取某个构造器：只能拿public修饰的某个构造器
    @Test
    public void getConstructor() throws Exception {
        // a.第一步：获取类对象
        Class c = Student.class;
        // b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)
        Constructor cons = c.getConstructor();
        System.out.println(cons.getName() + "===>" + cons.getParameterCount());
    }


    // 4.getConstructor(Class... parameterTypes)
    // 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。
    @Test
    public void getDeclaredConstructor() throws Exception {
        // a.第一步：获取类对象
        Class c = Student.class;
        // b.定位单个构造器对象 (按照参数定位无参数构造器)
        Constructor cons = c.getDeclaredConstructor();
        System.out.println(cons.getName() + "===>" + cons.getParameterCount());

        // c.定位某个有参构造器 加入相关接收类型的类型便可读取某个特定的有参构造器
        Constructor cons1 = c.getDeclaredConstructor(String.class, int.class);
        System.out.println(cons1.getName() + "===>" + cons1.getParameterCount());

    }

}
```

### Constructor类中用于创建对象的方法

| 符号                                      | 说明                                      |
| ----------------------------------------- | ----------------------------------------- |
| T newInstance(Object...  initargs)        | 根据指定的构造器创建对象                  |
| public  void setAccessible(boolean  flag) | 设置为true,表示取消访问检查，进行暴力反射 |

```java
// 1.调用构造器得到一个类的对象返回。
@Test
public void getDeclaredConstructor() throws Exception {
    // a.第一步：获取类对象
    Class c = Student.class;
    // b.定位单个构造器对象 (按照参数定位无参数构造器)
    Constructor cons = c.getDeclaredConstructor();
    System.out.println(cons.getName() + "===>" + cons.getParameterCount());

    // 如果遇到了私有的构造器，可以暴力反射
    cons.setAccessible(true); // 权限被打开

    Student s = (Student) cons.newInstance();
    System.out.println(s);

    System.out.println("-------------------");

    // c.定位某个有参构造器
    Constructor cons1 = c.getDeclaredConstructor(String.class, int.class);
    System.out.println(cons1.getName() + "===>" + cons1.getParameterCount());

    Student s1 = (Student) cons1.newInstance("孙悟空", 1000);
    System.out.println(s1);
}
```

### 小节

#### 利用反射技术获取构造器对象的方式

- getDeclaredConstructors()
- getDeclaredConstructor (Class<?>... parameterTypes)

#### 反射得到的构造器可以做什么？

- 依然是创建对象的
  - public newInstance(Object... initargs)
- 如果是非public的构造器，需要打开权限（暴力反射），然后再创建对象
  - setAccessible(boolean)
  - 反射可以破坏封装性，私有的也可以执行了。

## 反射获取成员变量对象

### 使用反射技术获取成员变量对象并使用

![](笔记图片资源包\snipaste20220224_142032.jpg)

- 反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。
- Class类中用于获取成员变量的方法

| 方法                                  | 说明                                         |
| ------------------------------------- | -------------------------------------------- |
| Field[]  getFields()                  | 返回所有成员变量对象的数组（只能拿public的） |
| Field[]  getDeclaredFields()          | 返回所有成员变量对象的数组，存在就能拿到     |
| Field  getField(String  name)         | 返回单个成员变量对象（只能拿public的）       |
| Field  getDeclaredField(String  name) | 返回单个成员变量对象，存在就能拿到           |

- 获取成员变量的作用依然是在某个对象中取值、赋值

```java
/**
     目标：反射_获取Field成员变量对象。

     反射的第一步是先得到Class类对象。

     1、Field getField(String name);
            根据成员变量名获得对应Field对象，只能获得public修饰
     2.Field getDeclaredField(String name);
            根据成员变量名获得对应Field对象，只要申明了就可以得到
     3.Field[] getFields();
            获得所有的成员变量对应的Field对象，只能获得public的
     4.Field[] getDeclaredFields();
            获得所有的成员变量对应的Field对象，只要申明了就可以得到
     小结：
        获取全部成员变量：getDeclaredFields
        获取某个成员变量：getDeclaredField
 */
public class FieldDemo01 {
    /**
     * 1.获取全部的成员变量。
     * Field[] getDeclaredFields();
     *  获得所有的成员变量对应的Field对象，只要申明了就可以得到
     */
    @Test
    public void getDeclaredFields()
    {
        //a、定位Class对象
        Class c=Student.class;
        //b、定位全部成员变量
        Field[] fields=c.getDeclaredFields();
        //c、遍历成员变量
        for (Field field : fields) {
            System.out.println(field.getName()+"==>"+field.getType());
        }
    }

    /**
        2.获取某个成员变量对象 Field getDeclaredField(String name);
     */
    @Test
    public void getDeclaredField() throws Exception {
        //a、定位Class对象
        Class c=Student.class;
        //b、根据名称定位某个成员变量
        Field field=c.getDeclaredField("age");
        System.out.println(field.getName()+"==>"+field.getType());
    }


}
```

### Field类中用于取值、赋值的方法

| 符号                                  | 说明     |
| ------------------------------------- | -------- |
| void  set(Object obj, Object value)： | 赋值     |
| Object  get(Object obj)               | 获取值。 |

```java
/**
    目标：反射获取成员变量: 取值和赋值。

    Field的方法：给成员变量赋值和取值
        void set(Object obj, Object value)：给对象注入某个成员变量数据
        Object get(Object obj):获取对象的成员变量的值。
        void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。
        Class getType(); 获取属性的类型，返回Class对象。
        String getName(); 获取属性的名称。
 */
public class FieldDemo02 {
    @Test
    public void setField() throws Exception {
        // a.反射第一步，获取类对象
        Class c = Student.class;
        // b.提取某个成员变量
        Field ageF = c.getDeclaredField("age");

        ageF.setAccessible(true); // 暴力打开权限

        // c.赋值
        Student s = new Student();
        ageF.set(s , 18);  // s.setAge(18);
        System.out.println(s);

        // d、取值
        int age = (int) ageF.get(s);
        System.out.println(age);

    }
}
```

### 小节

#### 1、利用反射技术获取成员变量的方式

- 获取类中成员变量对象的方法
  - getDeclaredFields()
  - getDeclaredField (String name)

#### 2、反射得到成员变量可以做什么？

- 依然是在某个对象中取值和赋值。
  - void set(Object obj, Object value)：
  - Object get(Object obj)
- 如果某成员变量是非public的，需要打开权限（暴力反射），然后再取值、赋值
  - setAccessible(boolean)

## 反射获取方法对象

### 使用反射技术获取方法对象并使用

![](笔记图片资源包\snipaste20220224_142811.jpg)

- 反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。
- Class类中用于获取成员方法的方法

| 方法                                                         | 说明                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| Method[]  getMethods()                                       | 返回所有成员方法对象的数组（只能拿public的） |
| Method[]  getDeclaredMethods()                               | 返回所有成员方法对象的数组，存在就能拿到     |
| Method  getMethod(String  name, Class<?>... parameterTypes)  | 返回单个成员方法对象（只能拿public的）       |
| Method  getDeclaredMethod(String  name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |

- 获取成员方法的作用依然是在某个对象中进行执行此方法

```java
/**
    目标：反射——获取Method方法对象

    反射获取类的Method方法对象：
         1、Method getMethod(String name,Class...args);
             根据方法名和参数类型获得对应的方法对象，只能获得public的

         2、Method getDeclaredMethod(String name,Class...args);
             根据方法名和参数类型获得对应的方法对象，包括private的

         3、Method[] getMethods();
             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的

         4、Method[] getDeclaredMethods();
            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。

    Method的方法执行：
        Object invoke(Object obj, Object... args)
          参数一：触发的是哪个对象的方法执行。
          参数二： args：调用方法时传递的实际参数
 */
public class MethodDemo01 {
    /**
     * 1.获得类中的所有成员方法对象
     */
    @Test
    public void getDeclaredMethods(){
        // a.获取类对象
        Class c = Dog.class;
        // b.提取全部方法；包括私有的
        Method[] methods = c.getDeclaredMethods();
        // c.遍历全部方法
        for (Method method : methods) {
            System.out.println(method.getName() +" 返回值类型：" + method.getReturnType() + " 参数个数：" + method.getParameterCount());
        }
    }

    /**
     * 2. 获取某个方法对象
     */
    @Test
    public void getDeclardMethod() throws Exception {
        // a.获取类对象
        Class c = Dog.class;
        // b.提取单个方法对象
        Method m = c.getDeclaredMethod("eat");
        									//	定位使用了特定的形参的方法
        Method m2 = c.getDeclaredMethod("eat", String.class);

        // 暴力打开权限了
        m.setAccessible(true);
        m2.setAccessible(true);

        // c.触发方法的执行
        Dog d = new Dog();
        // 注意：方法如果是没有结果回来的，那么返回的是null.
        Object result = m.invoke(d);
        System.out.println(result);

        Object result2 = m2.invoke(d, "骨头");
        System.out.println(result2);
    }
}
```

### Method类中用于触发执行的方法

| 符号                                      | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| Object invoke(Object obj, Object... args) | 运行方法  参数一：用obj对象调用该方法  参数二：调用方法的传递的参数（如果没有就不写）  返回值：方法的返回值（如果没有就不写） |

### 小节

#### 1、利用反射技术获取成员方法对象的方式

- 获取类中成员方法对象
  - getDeclaredMethods()
  - getDeclaredMethod (String name, Class<?>... parameterTypes) 

#### 2、反射得到成员方法可以做什么？

- 依然是在某个对象中触发该方法执行。
  - Object invoke(Object obj, Object... args)
- 如果某成员方法是非public的，需要打开权限（暴力反射），然后再触发执行
  - setAccessible(boolean)

## 反射的作用-绕过编译阶段为集合添加数据

- 反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(100);
// list.add(“黑马"); // 报错
list.add(99);
```

- 泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。

```java
public static void main(String[] args) throws Exception {
    // 需求：反射实现泛型擦除后，加入其他类型的元素
    ArrayList<String> lists1 = new ArrayList<>();
    ArrayList<Integer> lists2 = new ArrayList<>();
    //获取Class文件并输出文件路径
    System.out.println(lists1.getClass());
    System.out.println(lists2.getClass());

    System.out.println(lists1.getClass() ==  lists2.getClass());  // ArrayList.class

    System.out.println("---------------------------");
    ArrayList<Integer> lists3 = new ArrayList<>();
    lists3.add(23);
    lists3.add(22);
    // lists3.add("黑马");

    Class c = lists3.getClass(); // ArrayList.class  ===> public boolean add(E e)
    // 定位c类中的add方法
    Method add = c.getDeclaredMethod("add", Object.class);
    //获取方法后使用
    boolean rs = (boolean) add.invoke(lists3, "黑马");
    //输出结果
    System.out.println(rs);

    System.out.println(lists3);
//利用编译时，所有ArrayList集合都整合成ArrayList.class文件且list4的地址和list3的地址相同(指向的地址相同)，所以可以通过此方法修改。（没有用到反射）
    ArrayList list4 = lists3;
    list4.add("白马");
    list4.add(false);
    System.out.println(lists3);
}
```

### 小节

#### 反射为何可以给约定了泛型的集合存入其他类型的元素？

- 编译成Class文件进入运行阶段的时候，泛型会自动擦除。
- 反射是作用在运行时的技术，此时已经不存在泛型了。

## 反射的作用-通用框架的底层原理

### 案例：反射做通用框架

需求：给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。

![](笔记图片资源包\snipaste20220224_164137.jpg)



**需求**

给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。

**分析**

①定义一个方法，可以接收任意类的对象。

②每次收到一个对象后，需要解析这个对象的全部成员变量名称。

③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？

④使用反射获取对象的Class类对象，然后获取全部成员变量信息。

⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值

⑥存入成员变量名称和值到文件中去即可。

```java
public class MybatisUtil {
     /**
     保存任意类型的对象
     ①定义一个方法，可以接收任意类的对象。

     ②每次收到一个对象后，需要解析这个对象的全部成员变量名称。

     ③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？

     ④使用反射获取对象的Class类对象，然后获取全部成员变量信息。

     ⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值

     ⑥存入成员变量名称和值到文件中去即可。
     * @param obj
     */
    public static void save(Object obj){

        try(
           PrintStream ps=new PrintStream(new FileOutputStream("junit-reflect-annotation-proxy-app\\src\\data.txt",true));
                ) {

            //1.提取这个对象的全部成员变量
            Class c=obj.getClass();//getSimpleName()获取当前类名 c.getName 获取全限名：包名+类名
            ps.println("========================"+c.getSimpleName()+"========================");
            //2提取它的全部成员变量
            Field[]fields=c.getDeclaredFields();
            //3.获取成员变量的信息
            for (Field field : fields) {
                String name=field.getName();
                //提取本成员变量在obj对象中的取值
                field.setAccessible(true);
                String value=field.get(obj)+"";
                ps.println(name+"="+value);

            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 小节

#### 反射的作用？

- 可以在运行时得到一个类的全部成分然后操作。
- 可以破坏封装性。（很突出）
- 也可以破坏泛型的约束性。（很突出）
- 更重要的用途是适合：做Java高级框架
- 基本上主流框架都会基于反射设计一些通用技术功能。
- 反射：框架设计的灵魂

	* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
	* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
		* 好处：
			1. 可以在程序运行过程中，操作这些对象。
			2. 可以解耦，提高程序的可扩展性。


	* 获取Class对象的方式：
		1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
			* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
		2. 类名.class：通过类名的属性class获取
			* 多用于参数的传递
		3. 对象.getClass()：getClass()方法在Object类中定义着。
			* 多用于对象的获取字节码的方式
	
		* 结论：
			同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。


	* Class对象功能：
		* 获取功能：
			1. 获取成员变量们
				* Field[] getFields() ：获取所有public修饰的成员变量
				* Field getField(String name)   获取指定名称的 public修饰的成员变量
	
				* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
				* Field getDeclaredField(String name)  
			2. 获取构造方法们
				* Constructor<?>[] getConstructors()  
				* Constructor<T> getConstructor(类<?>... parameterTypes)  
	
				* Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)  
				* Constructor<?>[] getDeclaredConstructors()  
			3. 获取成员方法们：
				* Method[] getMethods()  
				* Method getMethod(String name, 类<?>... parameterTypes)  
	
				* Method[] getDeclaredMethods()  
				* Method getDeclaredMethod(String name, 类<?>... parameterTypes)  
	
			4. 获取全类名	
				* String getName()  


	* Field：成员变量
		* 操作：
			1. 设置值
				* void set(Object obj, Object value)  
			2. 获取值
				* get(Object obj) 
	
			3. 忽略访问权限修饰符的安全检查
				* setAccessible(true):暴力反射



	* Constructor:构造方法
		* 创建对象：
			* T newInstance(Object... initargs)  
	
			* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法


	* Method：方法对象
		* 执行方法：
			* Object invoke(Object obj, Object... args)  
	
		* 获取方法名称：
			* String getName:获取方法名


	* 案例：
		* 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法
			* 实现：
				1. 配置文件
				2. 反射
			* 步骤：
				1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
				2. 在程序中加载读取配置文件
				3. 使用反射技术来加载类文件进内存
				4. 创建对象
				5. 执行方法


## 