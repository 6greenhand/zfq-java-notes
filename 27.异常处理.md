# 异常处理

## 1、异常概述、体系

### **1.1、什么是异常？**

- 异常是程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中。 
- 比如:数组索引越界、空指针异常、 日期格式化异常，等…   

### 1.2、为什么要学习异常?

- 异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止.
- 研究异常并且避免异常，然后提前处理异常，体现的是程序的安全, 健壮性。

### 1.3、异常体系

![](笔记图片资源包\snipaste20220131_145727.jpg)

#### Error

- 系统级别问题、JVM退出等，代码无法控制。

#### Exception

**java.lang包下，称为异常类，它表示程序本身可以处理的问题**

- **RuntimeException及其子类**：运行时异常，编译阶段不会报错。 (空指针异常，数组索引越界异常) 
- **除RuntimeException之外所有的异常**：编译时异常，编译期必须处理的，否则程序不能通过编译。 (日期格式化异常)。 

### 1.4、编译时异常和运行时异常

![](笔记图片资源包\snipaste20220131_151108.jpg)

**简单来说**：

- 编译时异常就是在编译的时候出现的异常，
- 运行时异常就是在运行时出现的异常。

### 1.5、小节

#### 异常是什么？

- 异常是代码在编译或者执行的过程中可能出现的错误。

#### 异常分为几类？

- 编译时异常、运行时异常。
- 编译时异常：没有继承Runtime Excpetion的异常，编译阶段就会出错。
- 运行时异常：继承自Runtime Exception的异常或其子类，编译阶段不报错，运行可能报错。

#### 学习异常的目的？

- 避免异常的出现，同时处理可能出现的异常，让代码更稳健。

## 2、常见运行时异常

### 2.1、运行时异常

- 直接继承自Runtime Exception或者其子类，编译阶段不会报错，运行时可能出现的错误。

### 2.2、运行时异常示例

- 数组索引越界异常: Array Index Out Of Bounds Exception

- ```java
  /** 数组索引越界异常: ArrayIndexOutOfBoundsException。*/
          int[] arr = {1, 2, 3};
          System.out.println(arr[2]);
          // System.out.println(arr[3]); // 运行出错，程序终止
  ```

- 空指针异常 : Null Pointer Exception，直接输出没有问题，但是调用空指针的变量的功能就会报错。

- ```java
  /** 空指针异常 : NullPointerException。直接输出没有问题。但是调用空指针的变量的功能就会报错！！ */
  String name = null;
  System.out.println(name); // null
  // System.out.println(name.length()); // 运行出错，程序终止
  ```

- 数学操作异常：Arithmetic Exception

- ```java
  /** 数学操作异常：ArithmeticException。 */
  //int c = 10 / 0;
  ```

- 类型转换异常：Class Cast Exception

- ```java
  /** 类型转换异常：ClassCastException。 */
  Object o = 23;
  // String s = (String) o;  // 运行出错，程序终止
  ```

- 数字转换异常：Number Format Exception

- ```java
  String number = "23aabbc";
  Integer it = Integer.valueOf(number); // 运行出错，程序终止
  System.out.println(it + 1);
  ```

**运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，**
**自己的水平有问题！**

### 2.3、小节

#### 运行时异常的特点

- 运行时异常：继承自RuntimeException的异常或者其子类，
- 编译阶段不报错,运行可能报错。

## 3、常见编译时异常

### 3.1、编译时异常

- 不是Runtime Exception或者其子类的异常，编译阶就报错，必须处理，否则代码不通过

### 3.2、编译时异常示例

```java
String date = "2015-01-12 10:23:21";
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date d = sdf.parse(date);
System.out.println(d);
//报错，日期解析异常：Parse Exception
```

### 3.3、编译时异常的作用是什么

- 是担心程序员的技术不行，在编译阶段就报出一个错误, 目的在于提醒不要出错!
- 编译时异常是可遇不可求。遇到了就遇到了呗。

### 3.4、小节

#### 编译时异常的特点

- 编译时异常：继承自Exception的异常或者其子类
- 编译阶段报错，必须处理，否则代码不通过。

## 4、异常的默认处理流程

### 4.1、内容

1. 默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。
2. 异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。
3. 虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。
4. 直接从当前执行的异常点干掉当前程序。
5. 后续代码没有机会执行了，因为程序已经死亡。

### 4.2、小节

##### 默认异常处理机制。

- 默认的异常处理机制并不好，一旦真的出现异常，程序立即死亡！

## 5、编译时异常的处理机制

**编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过**

### 5.1、编译时异常的处理形式有三种

1. 出现异常直接抛出去给调用者，调用者也继续抛出去。
2.  出现异常自己捕获处理，不麻烦别人。
3.   前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。

### 5.2、异常处理方式1 —— throws

- throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。
- 这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。

#### 抛出异常格式

```java
方法 throws 异常1 ，异常2 ，异常3 ..{
}
规范做法
方法 throws Exception{
}

```

**代表可以抛出一切异常**

### 5.3、异常处理方式2 —— try…catch…

- 监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。
- 这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。

#### 格式

```java
   try{
   // 监视可能出现异常的代码！
   }catch(异常类型1 变量){
   // 处理异常
   }catch(异常类型2 变量){
   // 处理异常
   }...

```

#### 建议格式

```java
try{
// 可能出现异常的代码！
}catch (Exception e){
e.printStackTrace(); // 直接打印异常栈信息
}

Exception可以捕获处理一切异常类型！

```

### 5.4、异常处理方式3 —— 前两者结合

- 方法直接将异通过throws抛出去给调用者
- 调用者收到异常后直接捕获处理。

### 5.5、小节

- 在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理。

- 实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。

## 6、运行时异常的处理机制

#### 运行时异常的处理形式

- 运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。
- 按照规范建议还是处理：建议在最外层调用处集中捕获处理即可。 
- 运行时异常默认抛出给调用者，无需调用throws来抛出错误

## 7、异常处理使代码更稳健的案例

#### 需求

-  键盘录入一个合理的价格为止（必须是数值，值必须大于0）。

#### 分析

- 定义一个死循环，让用户不断的输入价格。

## 8、自定义异常

### 8.1、自定义异常的必要？

- Java无法为这个世界上全部的问题提供异常类。
- 如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。

### 8.2、自定义异常的好处

- 可以使用异常的机制管理业务问题，如提醒程序员注意。
- 同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。

### 8.3、自定义异常的分类

#### 8.3.1、自定义编译时异常

- 定义一个异常类继承Exception.

-  ```java
   public class gewuyouAgeilleagalException extends Exception{
       //重写构造器
       public gewuyouAgeilleagalException() {
       }
   
       public gewuyouAgeilleagalException(String message) {
           super(message);
       }
   }
   ```

- 重写构造器。

- 在出现异常的地方用throw new 自定义对象抛出，

-  ```java
   public static void checkAge(int age) throws gewuyouAgeilleagalException {
       if(age<0||age>200){
           //抛出异常
           //throw在方法内部创建一个异常对象，并从此处抛出
           //throws用在方法声明上的，用于抛出方法内部的异常
           throw new gewuyouAgeilleagalException(age+" is illegal!");
       }else {
           System.out.println("年龄合法，推荐商品给其购买");
       }
   
   }
   ```

- **作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！**

#### 8.3.2、自定义运行时异常

- 定义一个异常类继承RuntimeException.

- ```java
  public class gewuyouAgeilleagalException extends RuntimeException{
      //重写构造器
      public gewuyouAgeilleagalException() {
      }
  
      public gewuyouAgeilleagalException(String message) {
          super(message);
      }
  }
  ```

- 重写构造器。

- 在出现异常的地方用throw new 自定义对象抛出!

- ```java
  public static void checkAge(int age) {
          if(age<0||age>200){
              //抛出异常
              //throw在方法内部创建一个异常对象，并从此处抛出
              //throws用在方法声明上的，用于抛出方法内部的异常
              throw new gewuyouAgeilleagalRunTimeException(age+" is illegal!");
          }else {
              System.out.println("年龄合法，推荐商品给其购买");
          }
  
      }
  ```

- **作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！**

#### 8.3.3、throw与throws的区别

- throw在方法内部创建一个异常对象，并从此处抛出
- throws用在方法声明上的，用于抛出方法内部的异常