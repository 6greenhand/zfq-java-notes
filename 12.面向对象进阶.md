# 1、包

## 1.1、什么是包？

- 包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。
- 建包的语法格式：package 公司域名倒写.技术名称。包名建议全部英文小写，且具备意义

![](笔记图片资源包\snipaste20220123_101007.jpg)

- 
  建包语句必须在第一行，一般IDEA工具会帮助创建

## 1.2、**导包** 

- 相同包下的类可以直接访问，不同包下的类必须导包,才可以使用！导包格式：import 包名.类名;
- 假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问。

### 示例

```java
package com.gewuyou.d1_package;

import com.gewuyou.d1_package.demo1.Animal;
import com.gewuyou.d1_package.demo1.Cat;

public class Test {
    public static void main(String[] args) {
        //掌握导包，相同包下的类可以访问
        Student student=new Student();
        //不同包下的类，需要导包才能访问
        Animal animal=new Animal();
        Cat cat=new Cat();
        com.gewuyou.d1_package.demo2.Cat cat1=new com.gewuyou.d1_package.demo2.Cat();
    }
}

```

# 2、权限修饰符

## 2.1、什么是权限修饰符？

- 权限修饰符：是用来控制一个成员能够被访问的范围的。
- 可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。

## 2.2、权限修饰符的分类和具体作用范围

- 权限修饰符：有四种作用范围由小到大（private -> 缺省 -> protected - > public ）

![](笔记图片资源包\snipaste20220123_103408.jpg)

## 2.3学完权限修饰符需要具备如下能力

- 能够识别别人定义的成员的访问权限。
- 自己定义成员（方法，成员变量，构造器等）一般满足如下要求：
  - 成员变量一般私有。
  - 方法一般公开。
  - 如果该成员只希望本类访问，使用private修饰。
  - 如果该成员只希望本类，同一个包下的其他类和子类访问，使用protected修饰。

# 3、final关键字

## 3.1、final的作用

- final 关键字是最终的意思，可以修饰（方法，变量，类）
- 修饰方法：表明该方法是最终方法，不能被重写。
- 修饰变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。
- 修饰类：表明该类是最终类，不能被继承。

## 3.2、final修饰变量的注意事项

- final修饰的变量是基本类型：那么变量存储的数据值不能发生改变。
- final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。

# 4、常量

## 4.1、常量概述和基本作用

### 常量 

-  常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。
-  常量的作用和好处：可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性。

![](笔记图片资源包\snipaste20220123_115403.jpg)

- 常量命名规范：英文单词全部大写，多个单词下划线连接起来。

### 常量的执行原理

- 在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。
- 这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。

## 4.2、常量做信息标志和分类

### 案例说明

- 现在开发的超级玛丽游戏需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向。

### 选择常量做信息标志和分类

- 代码可读性好，实现了软编码形式。

# 5、枚举

## 5.1、枚举的概述

### 枚举的概述

- 枚举是Java中的一种特殊类型
- 枚举的作用："是为了做信息的标志和信息的分类"。

### 定义枚举类的格式

![](笔记图片资源包\snipaste20220123_130140.jpg)

![](笔记图片资源包\snipaste20220123_130157.jpg)

### 反编译后观察枚举的特征

![](笔记图片资源包\snipaste20220123_130328.jpg)

![snipaste20220123_130343](笔记图片资源包\snipaste20220123_130343.jpg)

### 枚举的特征

- 枚举类都是继承了枚举类型：java.lang.Enum
- 枚举都是最终类，不可以被继承。
- 构造器都是私有的，枚举对外不能创建对象。
- 枚举类的第一行默认都是罗列枚举对象的名称的。
- 枚举类相当于是多例模式。

## 5.2、枚举的使用场景演示

### 案例说明

- 现在开发的超级玛丽游戏需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向。

### 选择常量做信息标志和分类

- 虽然可以实现可读性，但是入参值不受约束，代码相对不够严谨。

### 枚举做信息标志和分类

- 代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术！建议使用!

# 6、抽象类

## 6.1、抽象类概述

### 抽象类

- 在Java中abstract是抽象的意思，如果一个类中的某个方法的具体实现不能确定，就可以申明成abstract修饰的抽象方法（不能写方法体了），这个类必须用abstract修饰，被称为抽象类。
- 某个父类知道其所有子类要完成某功能，但是每个子类完成情况都不一样，父类就只定义该功能的基本要求，具体实现由子类完成，这个类就可以是一个抽象类，抽象类其实就是一种不完全的设计图。

### 抽象方法

- 就是抽象类中定义的子类必须完成的功能的基本要求。

- 没有方法体，只有方法签名，必须abstract修饰。

![](笔记图片资源包\snipaste20220123_140930.jpg)

### 抽象的使用总结与注意事项

- 抽象类用来被继承的，抽象方法是交给子类重写实现的。
- 一个类如果继承了抽象类，那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。

#### 思考

##### 1、抽象类的作用是什么样的？什么时候定义抽象类？

- 可以被子类继承、充当模板的、同时也可以提高代码复用。
- 如果父类知道子类要完成某个功能，实现要交给子类时要定义抽象类。

##### 2、抽象方法是什么样的？

- 只有方法签名，没有方法体，使用了abstract修饰。

##### 3、继承抽象类有哪些要注意？

- 一个类如果继承了抽象类，那么这个类必须重写完抽象类的全部抽象方法。
- 否则这个类也必须定义成抽象类。

## 6.2、抽象类的特征、注意事项

### 特征和注意事项

- 有得有失: 得到了抽象方法，失去了创建对象的能力。
- 抽象类为什么不能创建对象？
-  类有的成员（成员变量、方法、构造器）抽象类都具备
- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
- 一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。
- 不能用abstract修饰变量、代码块、构造器。

### final和abstract的关系

- 互斥关系
- abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承。
- 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写

## 6.3、抽象类的应用知识：模板方法模式

### 模板方法模式使用契机

- 使用场景说明：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候。

### 模板方法模式实现步骤

- 把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码。
- 模板方法中不能决定的功能定义成抽象方法让具体子类去实现。

#### 思考

##### 模板方法我们是建议使用final修饰的，这样会更专业，那么为什么呢？

- 答：模板方法是给子类直接使用的，不是让子类重写的，一旦子类重写了模板方法就失效了。

##### 模板方法模式解决了什么问题？

-  极大的提高了代码的复用性
-  模板方法已经定义了通用结构，模板不能确定的定义成抽象方法。
-  使用者只需要关心自己需要实现的功能即可。

# 7、接口

## 7.1、接口概述、特点

### 什么是接口

- 接口是一种规范
- 接口就是体现规范的，其中用抽象方法定义的一组行为规范，接口是更加彻底的抽象。
- 体现了现实世界中"如果你是这类事物...则必须完成某些行为...的思想"。

### 接口的定义与特点

- 接口的格式如下：           ![](笔记图片资源包\snipaste20220123_161842.jpg)

- JDK8之前接口中只能是抽象方法和常量，没有其他成分了。
- 接口不能实例化。
- 接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化。

## 7.2、接口的基本使用：被实现

### 接口的用法

- 接口是用来被类实现（implements）的，实现接口的类称为实现类。实现类可以理解成所谓的子类。

![](笔记图片资源包\snipaste20220123_165043.jpg)

- 从上面可以看出，接口可以被类单实现，也可以被类多实现。


### 接口实现的注意事项

- 一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。

## 7.3、接口与接口的关系：多继承

### 基本小结

- 类和类的关系：单继承。
- 类和接口的关系：多实现。
- 接口和接口的关系：多继承，一个接口可以同时继承多个接口。

### 接口多继承的作用

- 规范合并，整合多个接口为同一个接口，便于子类实现。

## 7.4、JDK8开始接口新增方法

### 导言

- JDK8版本开始后，Java只对接口的成员方法进行了新增

### 新增原因

- 由于项目升级，需要对接口功能丰富化，加入了新的抽象方法，但由于接口本身新增了抽象方法，导致接口发生改变，需要所有的实现类去实现新增方法，这对于实现类多的项目会导致工作量增大，增大开发成本。

### 思考

#### 如何能在丰富接口功能的同时又不对子类代码进行更改呢？

为此java新增了相关内容来解决问题。

- 允许接口中直接定义带有方法体的方法

### 新增内容

#### 第一种：默认方法

- 类似之前写的普通实例方法：必须用default修饰
- 默认会public修饰。由于接口无法创建对象，所以需要用接口的实现类的对象来调用

![](笔记图片资源包\snipaste20220123_174459.jpg)

#### 第二种：静态方法

- 默认会public修饰，必须static修饰。
- 注意：接口的静态方法必须用本身的接口名来调用。
- 也就是说无法使用间接（套娃）的方式去调用

![](笔记图片资源包\snipaste20220123_174619.jpg)

#### 第三种：私有方法

- 就是私有的实例方法:，必须使用private修饰，从JDK 1.9才开始有的。
- 只能在本类中被其他的默认方法或者私有方法访问。

![](笔记图片资源包\snipaste20220123_174842.jpg)

### 小节

#### JDK8开始后新增了那些方法?

- 默认方法：default修饰，实现类对象调用。
- 静态方法：static修饰，必须用当前接口名调用
- 私有方法：private修饰，jdk9开始才有的，只能在接口内部被调用。
- 他们都会默认被public修饰。

#### 注意

- JDK8新增的3种方法我们自己在开发中很少使用，通常是Java源码涉及到的，我们需要理解、识别语法、明白调用关系即可。

## 7.5、使用接口的注意事项

1. 接口不能创建对象
2. 一个类实现多个接口，多个接口中有同样的静态方法不冲突。
3. 一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。
4. 一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可。
5. 一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。