# 注解

## 注解概述

### 概述

- Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。
- Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。

```java
public class UserServiceTest {
@Test//注解（Annotation）
public void testLogin(){
}
@Test//注解（Annotation）
public void testChu(){
}
}

```

### 作用

- 对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。
- 例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行

### 小节

#### 注解的作用

- 对Java中类、方法、成员变量做标记，然后进行特殊处理。
- 例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行

## 自定义注解

### 自定义注解 --- 格式

- 自定义注解就是自己做一个注解来使用。

```java
public @interface 注解名称 {
public 属性类型 属性名() default 默认值 ;
}		   ||
    	   \/
//Java支持的数据类型基本上都支持
```

### 特殊属性

- value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!
- 但是如果有多个属性,  且多个属性没有默认值，那么value名称是不能省略的。

## 元注解

### 概念

- 元注解：就是注解注解的注解。 

### 种类

元注解有两个：

-  @Target: 约束自定义注解只能在哪些地方使用，
-  @Retention：申明注解的生命周期       

#### @Target

@Target中可使用的值定义在ElementType枚举类中，常用值如下

- TYPE，类，接口
- FIELD, 成员变量
- METHOD, 成员方法
- PARAMETER, 方法参数
- CONSTRUCTOR, 构造器
- LOCAL_VARIABLE, 局部变量

#### @Retention

@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下

- SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在
- CLASS：  注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.
- RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）

### 小节

#### 元注解是什么？

- 注解注解的注解
- @Target约束自定义注解可以标记的范围。 @Retention用来约束自定义注解的存活范围。

## 注解解析

### 注解的解析

- 注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。

### 与注解解析相关的接口

- Annotation: 注解的顶级接口，注解都是Annotation类型的对象
- AnnotatedElement:该接口定义了与注解解析相关的解析方法

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Annotation[]  getDeclaredAnnotations()                       | 获得当前对象上使用的所有注解，返回注解数组。                 |
| T getDeclaredAnnotation(Class<T>  annotationClass)           | 根据注解类型获得对应注解对象                                 |
| boolean isAnnotationPresent(Class<Annotation>  annotationClass) | 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false |

- 所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力：

### 解析注解的技巧

- 注解在哪个成分上，我们就先拿哪个成分对象。
-  比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解
-  比如注解作用在类上，则要该类的Class对象，再来拿上面的注解
-  比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解

### 注解解析的案例

需求：注解解析的案例

分析

①定义注解Book，要求如下：
     \- 包含属性：String value()  书名
     \- 包含属性：double price() 价格，默认值为 100
     \- 包含属性：String[] authors() 多位作者
     \- 限制注解使用的位置：类和成员方法上
     \- 指定注解的有效范围：RUNTIME

②定义BookStore类，在类和成员方法上使用Book注解

③定义AnnotationDemo01测试类获取Book注解上的数据

```java
@Target({ElementType.TYPE,ElementType.METHOD})//类和成员方法上
@Retention(RetentionPolicy.RUNTIME)//RUNTIME
public @interface Bookk {
    String value();//书名
    double price() default 100;//价格，默认值为 100
    String[] author();//多位作者
}
```

### 小节

#### 注解解析的方式

| 方法                                                         |
| ------------------------------------------------------------ |
| Annotation[]  getDeclaredAnnotations()                       |
| T getDeclaredAnnotation(Class<T>  annotationClass)           |
| boolean isAnnotationPresent(Class<Annotation>  annotationClass) |

### 注解速查

* 概念：说明程序的。给计算机看的
* 注释：用文字描述程序的。给程序员看的

* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
* 概念描述：
	* JDK1.5之后的新特性
	* 说明程序的
	* 使用注解：@注解名称

* 作用分类：
	①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
	②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
	③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】

* JDK中预定义的一些注解
	* @Override	：检测被该注解标注的方法是否是继承自父类(接口)的
	* @Deprecated：该注解标注的内容，表示已过时
	* @SuppressWarnings：压制警告
		* 一般传递参数all  @SuppressWarnings("all")

* 自定义注解
	* 格式：
		元注解
		public @interface 注解名称{
			属性列表;
		}

	* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口
		* public interface MyAnno extends java.lang.annotation.Annotation {}

	* 属性：接口中的抽象方法
		* 要求：
			1. 属性的返回值类型有下列取值
				* 基本数据类型
				* String
				* 枚举
				* 注解
				* 以上类型的数组

			2. 定义了属性，在使用时需要给属性赋值
				1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
				2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。
				3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略
	
	* 元注解：用于描述注解的注解
		* @Target：描述注解能够作用的位置
			* ElementType取值：
				* TYPE：可以作用于类上
				* METHOD：可以作用于方法上
				* FIELD：可以作用于成员变量上
		* @Retention：描述注解被保留的阶段
			* @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
		* @Documented：描述注解是否被抽取到api文档中
		* @Inherited：描述注解是否被子类继承

* 在程序使用(解析)注解：获取注解中定义的属性值
	1. 获取注解定义的位置的对象  （Class，Method,Field）
	2. 获取指定的注解
		* getAnnotation(Class)
		  //其实就是在内存中生成了一个该注解接口的子类实现对象

	     ```java
	        public class ProImpl implements Pro{
	            public String className(){
	                return "cn.itcast.annotation.Demo1";
	            }
	            public String methodName(){
	                return "show";
	            }
	        }
	     ```
	3. 调用注解中的抽象方法获取配置的属性值

## 注解的应用场景

### junit框架

#### 案例：模拟Junit框架

**需求**

定义若干个方法，只要加了MyTest注解，就可以在启动时被触发执行

**分析**

①定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在。

②定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行。

```java
@Target({ElementType.METHOD,ElementType.FIELD}) // 元注解
@Retention(RetentionPolicy.RUNTIME) // 一直活着，在运行阶段这个注解也不消失
public @interface MyTest {
}
-----------------------------------------------------
public void test1(){
        System.out.println("===test1===");
    }

    @MyTest
    public void test2(){
        System.out.println("===test2===");
    }

    @MyTest
    public void test3(){
        System.out.println("===test3===");
    }

    /**
      启动菜单：有注解的才被调用。
     */
    public static void main(String[] args) throws Exception {
        AnnotationDemo4 t = new AnnotationDemo4();
        // a.获取类对象
        Class c = AnnotationDemo4.class;
        // b.提取全部方法
        Method[] methods = c.getDeclaredMethods();
        // c.遍历方法，看是否有MyTest注解，有就跑它
        for (Method method : methods) {
            if(method.isAnnotationPresent(MyTest.class)){
                // 跑它
                method.invoke(t);
            }
        }
    }    
```
